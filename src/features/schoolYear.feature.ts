import { inject, injectable } from "inversify";
import { TYPES } from "../config/types";
import {
  AuditableEntities,
  AuditLogActions,
  PrismaClient,
  SchoolMonth,
  SchoolPeriod,
  SchoolYear,
  Settings,
} from "@prisma/client";
import {
  SearchArgs,
  SearchResult,
  searchWithPaginationAndCriteria,
} from "../lib/search";
import createHttpError from "http-errors";
import { ExtendedPrisma } from "../config/container";
import { AuditLogService } from "../services/auditLog.service";
import { SchoolPeriodFeature } from "./schoolPeriod.feature";
import { SchoolMonthFeature } from "./schoolMonth.feature";
import { SettingsService } from "../services/settings.service";

@injectable()
export class SchoolYearFeature {
  constructor(
    @inject(TYPES.Prisma)
    private readonly prisma: ExtendedPrisma,
    @inject(TYPES.AuditLogService)
    private readonly auditLogService: AuditLogService,
    @inject(TYPES.SchoolPeriodFeature)
    private readonly schoolPeriodFeature: SchoolPeriodFeature,
    @inject(TYPES.SchoolMonthFeature)
    private readonly schoolMonthFeature: SchoolMonthFeature,
    @inject(TYPES.SettingsService)
    private readonly settingsService: SettingsService
  ) {}

  public async create(
    startDate: Date,
    endDate: Date,
    automaticallyGenerateSchoolPeriodsAndMonths: boolean
  ): Promise<{
    schoolYear: SchoolYear;
    extraAutoGeneratedData: {
      generatedMonths: SchoolMonth[];
      firstPeriod: SchoolPeriod;
      secondPeriod: SchoolPeriod;
      thirdPeriod: SchoolPeriod;
    } | null;
  }> {
    const name = `AÑO-ESCOLAR-${startDate.getFullYear()}-${endDate.getFullYear()}`;

    const existingSchoolYear = await this.prisma.schoolYear.count({
      where: {
        startDate,
        endDate,
        deletedAt: null,
      },
    });

    if (existingSchoolYear > 0) {
      throw createHttpError(
        409,
        "Ya existe un año escolar con esta fecha de inicio y fin."
      );
    }

    const schoolYear = await this.prisma.schoolYear.create({
      data: {
        name,
        startDate,
        endDate,
      },
    });

    this.auditLogService.createLog(
      AuditableEntities.SCHOOL_YEAR,
      AuditLogActions.CREATE,
      schoolYear
    );

    let extraAutoGeneratedData: {
      generatedMonths: SchoolMonth[];
      firstPeriod: SchoolPeriod;
      secondPeriod: SchoolPeriod;
      thirdPeriod: SchoolPeriod;
    } | null = null;

    if (automaticallyGenerateSchoolPeriodsAndMonths) {
      const periodAlias = await this.settingsService.get(Settings.PERIOD_ALIAS);

      const firstPeriod = await this.schoolPeriodFeature.create(
        `${periodAlias}-1-${startDate.getFullYear()}-${endDate.getFullYear()}`,
        schoolYear.id
      );
      const secondPeriod = await this.schoolPeriodFeature.create(
        `${periodAlias}-2-${startDate.getFullYear()}-${endDate.getFullYear()}`,
        schoolYear.id
      );
      const thirdPeriod = await this.schoolPeriodFeature.create(
        `${periodAlias}-3-${startDate.getFullYear()}-${endDate.getFullYear()}`,
        schoolYear.id
      );

      const generatedMonths =
        await this.schoolMonthFeature.generateSchoolMonths({
          firstPeriod: firstPeriod.id,
          secondPeriod: secondPeriod.id,
          thirdPeriod: thirdPeriod.id,
        });

      extraAutoGeneratedData = {
        generatedMonths,
        firstPeriod,
        secondPeriod,
        thirdPeriod,
      };
    }

    return { schoolYear, extraAutoGeneratedData };
  }

  public async update(
    id: number,
    data: Partial<{
      name: string;
      startDate: Date;
      endDate: Date;
    }>
  ): Promise<SchoolYear> {
    const schoolYear = await this.prisma.schoolYear.findUnique({
      where: {
        id,
        deletedAt: null,
      },
    });

    if (!schoolYear) {
      throw createHttpError(404, "Año escolar no encontrado.");
    }

    if (data.name && data.name !== schoolYear.name) {
      const existingSchoolYear = await this.prisma.schoolYear.count({
        where: {
          name: data.name,
          deletedAt: null,
        },
      });

      if (existingSchoolYear > 0) {
        throw createHttpError(409, "Ya existe un año escolar con este nombre.");
      }
    }

    const start = data.startDate ?? schoolYear.startDate;
    const end = data.endDate ?? schoolYear.endDate;

    if (start.getTime() > end.getTime()) {
      throw createHttpError(
        400,
        "El año de inicio no puede ser mayor al año de finalización."
      );
    }

    const updatedSchoolYear = await this.prisma.schoolYear.update({
      where: {
        id,
        deletedAt: null,
      },
      data,
    });

    this.auditLogService.createLog(
      AuditableEntities.SCHOOL_YEAR,
      AuditLogActions.UPDATE,
      { data }
    );

    return updatedSchoolYear;
  }

  public async softDelete(id: number): Promise<SchoolYear> {
    const schoolYear = await this.prisma.schoolYear.update({
      where: {
        id,
        deletedAt: null,
      },
      data: {
        deletedAt: new Date(),
      },
    });

    this.auditLogService.createLog(
      AuditableEntities.SCHOOL_YEAR,
      AuditLogActions.SOFT_DELETE,
      { deletedAt: schoolYear.deletedAt }
    );

    return schoolYear;
  }

  public async hardDelete(id: number): Promise<SchoolYear> {
    const schoolYear = await this.prisma.schoolYear.delete({
      where: {
        id,
        deletedAt: {
          not: null,
        },
      },
    });

    this.auditLogService.createLog(
      AuditableEntities.SCHOOL_YEAR,
      AuditLogActions.DELETE,
      {}
    );

    return schoolYear;
  }

  public async findById(
    id: number,
    includeDeleted: boolean
  ): Promise<SchoolYear | null> {
    return await this.prisma.schoolYear.findUnique({
      where: {
        id,
        ...(includeDeleted ? {} : { deletedAt: null }),
      },
    });
  }

  public async search(
    args: SearchArgs<
      Partial<
        Omit<SchoolYear, "id" | "deletedAt" | "createdAt" | "updatedAt">
      > & {
        deletedAt?: {
          not: null;
        };
      }
    >
  ): Promise<SearchResult<SchoolYear>> {
    return searchWithPaginationAndCriteria<SchoolYear>(
      this.prisma.schoolYear.findMany.bind(this.prisma.schoolYear),
      this.prisma.schoolYear.similarity.bind(this.prisma.schoolYear),
      {
        ...args,
        where: { ...args.where },
      },
      await this.settingsService.get(Settings.SEARCH_THRESHOLD)
    );
  }

  public async getActualSchoolYear(): Promise<SchoolYear | null> {
    const today = new Date();

    const schoolYear = await this.prisma.schoolYear.findFirst({
      where: {
        startDate: { lte: today },
        endDate: { gte: today },
        deletedAt: null,
      },
    });

    if (!schoolYear) {
      return null;
    }

    return schoolYear;
  }
}
